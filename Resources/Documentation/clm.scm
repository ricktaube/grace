;
;; Working with SndLib
;

; To run examples put the cursor at the end of each expression and
; press Command-Return. Look in the console window for any output.

; SndLib is a C/Scheme toolkit for digital audio geneneration. It
; contains CLM, a synthesis language the provides many kinds of
; 'unit generators' for creating digital audio, CLM also contains
; many predefined audio instruments that you can browse using
; the Audio Menu's Instruments Browser.

; SndLib instruments are stored in files. To work with an instrument
; you first need to load it into Scheme.  Let's load a simple sine
; wave instrument from the instrument distribution:

(load "wave.scm")

; The load command searches the embedded distribution if the filename
; you provide has no directory and the file is not found in the
; current working directory. Now that we've loaded the file let's look
; at the instument's documentation:

(procedure-documentation wave)

; Most SndLib instruments come with Scheme documentation.  The wave
; documentation tells us that this instrument is a sine wave with
; envelope controls for amplitude and frequency skew (glissando). We
; can also see that we only have to provide four values to generate
; sound: time, dur, freq and amp. The order of these parameters follow
; a very common convention in SndLib instruments: 'time' is the start
; time in second of the sound in the output file; 'dur' is the time in
; seconds that the sound will last; 'freq' is the frequency in HERTZ
; of the sound (Note that you can use the hertz() function to convert key
; numbers and note names to hertz values when you call the function.)
; and 'amp' is the sound level: 0 is no sound and 1 is completely
; saturated sound. Amplitude values should be 0 < amp < 1. Note that
; in SndLib this sound level is ADDITIVE: the SUM of amplitudes of all
; instruments should be less than 1.  The rule of thumb for working
; with amp values is: choose the smallest value that works for a given
; sound.

;
;; Calling instruments to make sound
;

; To listen to the wave instrument we will send it time dur freq and
; amp values to generate audio. But recall that SndLib generates audio
; to audio files (aka "sound files").  This means that we also need a
; sound file to write to. THere are several ways to do this, the
; simplest way is to use the 'soundfile' command to wrap our sends
; inside a 'context' that insures a sound file is open.

(with-sound (:output "test.wav" )
  (wave 0 1 440 .05)
  )

; 'with-sound' is a "wrapper" that makes sure a CLM audio file is open
; and ready to receive audio samples generated by instrument calls
; inside it. Soundfiles have a number of optional arguments that you
; can use to set certain audio characteritics of the file. The two
; most important arguments are ':srate' -- the sample rate of the file
; -- and ':channels' -- the number of auio channels in the audio
; file. These settings are important to understand because they
; directly affect the quality, size, and amount of time it takes to
; write a soundfile. For example, an audio file written with two
; channels will allow you place your sounds in stereo space but the
; file will be twice as big as a mono channel. A file written with a
; srate of 44100 may improve the fidelity of the audio but it will
; take twice as long to compute the file as an srate of 22050. In
; general you will want to work with mono at 22050 you are testing
; things out, and then switch to CD quality (stereo at 44100) when you
; are generating audio you intend to use.  Note that you can set the
; "default" values for these settings in the Audio>SndLib menu that
; and that you can override the default by explicitly passing :srate
; and :channels to the 'with-sound' command.

; This next example demonstrates CD quailty output. Since the file
; will have two channels we can also demonstrate panning in stereo
; space.  The convention in SndLib is specify a sound's location in
; degrees. So in stereo space degree 0 is full left channel, 45 puts
; the sound equally in both channels, and 90 is full right.  This next
; example generates three notes, the first full left, the second in
; the middle and the third full right channel

(with-sound (:output "test.wav" :srate 44100 :channels 2)
  (wave 0 1 220 .05 :degree 0)
  (wave 1 1 440 .05 :degree 45)
  (wave 2 1 880 .05 :degree 90)
  )

; This next example pans a series of notes from full left to full
; right.  It also demonstrates how to write a soundfile to a specfic
; directory on a mac or linux. Inside the soundfile we use a local
; variable and a loop that generates the events moving from left to
; right.

(with-sound (:output "test.wav" :channels 2)
  (let ((totdur 4))
    (loop for t from 0 below totdur by .25
          do
          (wave t .2 (rescale t 0 totdur 220 880) .1
                :degree (rescale t 0 totdur 0 90)))
    (wave totdur 2 220 .1 :degree 45)
    (wave totdur 2 880 .1 :degree 45)
    ))

;
;; SndLib Envelopes
;

;
;; Location and Reverb
;

;
;; Using processes to generate SndLib Audio
;

; The 'soundfile' command is a lexical environment (code block) that
; generates a sound file from the enclosed statements. But we can We
; can also generate soundfiles 'dynamically' by running musical
; processes in the scheduler. To do you simply write processes that
; send data to sndlib instruments and then pass the sound file name to
; the sprout command.  But there is one small catch: remember that
; sndlib instruments always expect a 'start time' for the sound sound
; in the sound file. To get this value in the scheduler you can use
; elapsed(#t) to get the true time of the running process.

(define (simpwav n r d lb ub)
  (process repeat n
           for k = (between lb ub)
           do
           (wave (elapsed #t) d (hertz k) .1)
           (wait r)
           ))

(sprout (simpwav 10 .2 .1 60 80) "test.wav")

; This next example defines an 'additive synthesis' process called
; gong that creates a gong-like (complex) waveform by calling wave to
; create each partial in the gong timbre.

(define (gong num dur freq amp loc dist rev)
  (process repeat num
           for frq = (between freq (* freq 3))
           do
           (wave (elapsed #t) dur frq amp
                 :ampenv '(0 0 1 1 10 .5 40 .2 100 0)
                 :reverb rev
                 :degree loc
                 :dist dist)
           ))

(sprout (gong 2 2 440 .1 45 0 0) "gong.wav")

(sprout (gong 8 2 440 .05 45 0 0) "gong.wav" :channels 2)

; Define a process to sprout the gong processes.

(define (gongalong num rate dur freqenv)
  (process for i below num
           do
           (sprout (gong (pick 2 3) dur (interp (/ i num) freqenv)
                         .05 45 0 0))
           (wait rate)
           ))

(sprout (gongalong 20 .5 2 '(0 440 1 300)), "gongalong.wav")
