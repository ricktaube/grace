;;; **********************************************************************
;;; Copyright 1999-2014 Rick Taube.  All rights reserved.
;;; Licensed under the "Attribution-NonCommercial-ShareAlike" Vizsage
;;; Public License, which says that non-commercial users may share and
;;; modify this code but must give credit and share improvements. For
;;; complete terms please read the text of the full license available at
;;; this link: http://vizsage.com/license/Vizsage-License-BY-NC-SA.html
;;; **********************************************************************

(define (interp1 x coords base)
  (let* ((x1 (if (null? coords)
		 (error "~S is an empty x y coordinate list" coords)
		 (car coords)))
	 (y1 (if (null? (cdr coords))
		 (error "malformed x y coordinate list ~S" coords)
		 (cadr coords)))
	 (x2 x1)
	 (y2 y1)
	 (b base))
    (do ((tail (cddr coords) (cddr tail)))
	((or (null? tail) (> x2 x))
	 (ffi_rescale x x1 x2 y1 y2 b))
      (set! x1 x2)
      (set! y1 y2 )
      (set! x2 (car tail)) 
      (if (null? (cdr tail))
	  (error "malformed envelope list ~S" coords)
	  (set! y2 (cadr tail))))))

(define (interp x . args)
  (if (null? args) (error "empty envelope list ~S" args))
  (if (pair? (car args))
      (interp1 x (car args) 
	       (if (null? (cdr args)) 1 (cadr args)))
      (interp1 x args 1)))

(define (tendency x low high . args)
  (let ((rgen ran))
    (if (not (null? args))
	(begin (set! rgen (car args)) (set! args (cdr args))))
    (if (pair? low) (set! low (interp1 x low 1)))
    (if (pair? high) (set! high (interp1 x high 1)))
    (if (= low high)
	low
	(+ low (apply rgen
		      (if (> low high) (- low high) (- high low))
		      args)))))

;(define (ranenv n) (loop for i to n append (list (* (/ i n) 100.0) (random 100))))
;(define (randata n) (loop repeat n collect (random 100)))
;(define foo (ranenv 12))
;foo
;(ranenv 5)

(define (list->envelope vals . args)
  (with-optkeys (args (x0 0) (x1 1))
    (let* ((s (length vals))
           (h (list #t))
           (i (/ (- x1 x0) (- s 1))))
      (if (< s 2)
        (error "envelopes require at least two values but ~S were given: ~S"
               s vals))
      (if (>= x0 x1)
        (error "bad envelope range: x1 ~S is not greater than x0 ~S." x0 x1))
      (do ((y vals (cdr y))
           (x x0 (+ x i))
           (t h))
          ((null? y) (cdr h))
        (set! (cdr t) (list x (car y)))
        (set! t (cddr t))))))

;(list->envelope (loop repeat 4 collect (random 100) ))
;(list->envelope (loop repeat 5 collect (random 100)) 100.0 200.0)

(define (envelope->list env . coord)
  (if (null? coord)
    (set! coord :y)
    (if (null? (cdr coord))
      (set! coord (car coord))
      (error "too many arguments: ~S." (cons env coord))))
  (cond ((eq? coord :y)
         (let ((h (list #t)))
           (do ((e env (cddr e))
                (t h))
               ((null? e) (cdr h))
             (set! (cdr t) (list (cadr e)))
             (set! t (cdr t)))))
        ((eq? coord :x)
         (let ((h (list #t)))
           (do ((e env (cddr e))
                (t h))
               ((null? e) (cdr h))
             (set! (cdr t) (list (car e)))
             (set! t (cdr t)))))
    (else (error "coord ~S is not :x or :y." coord))))

;(envelope->list '(0 -1 .2 10 .5 0 1 99) :x)

(define (envelope-min env . coord)
  (if (null? coord)
    (set! coord :y)
    (if (null? (cdr coord))
      (set! coord (car coord))
      (error "more than one optional argument: ~S." coord)))
  (cond ((eq? coord :y)
         (do ((e env (cddr e))
              (y #f))
             ((null? e) y)
           (set! y (if y (min y (cadr e)) (cadr e)))))
        ((eq? coord :x)
         (car env))
        (else 
          (error "coord ~S not :x or :y." coord))))

;(envelope-min '(0.0 23 20.0 73 40.0 37 60.0 8 80.0 76 100.0 36) :x)
;(envelope-min '(0.0 23 20.0 73 40.0 37 60.0 8 80.0 76 100.0 36) :y)

(define (envelope-max env . coord)
  (if (null? coord)
    (set! coord :y)
    (if (null? (cdr coord))
      (set! coord (car coord))
      (error "more than one optional argument: ~S." coord)))
  (cond ((eq? coord :y)
         (do ((e env (cddr e))
              (y #f))
             ((null? e) y)
           (set! y (if y (max y (cadr e)) (cadr e)))))
        ((eq? coord :x)
         (do ((e env (cddr e))
              (x #f))
             ((null? e) x)
           (set! x (car e))))
        (else (error "coord ~S not :x or :y." coord))))

;(envelope-max '(0.0 23 20.0 73 40.0 37 60.0 8 80.0 76 100.0 36) :x)
;(envelope-max '(0.0 23 20.0 73 40.0 37 60.0 8 80.0 76 100.0 36) :y)

(define (envelope-average env . coord)
  (if (null? coord)
      (set! coord :y)
      (if (null? (cdr coord))
          (set! coord (car coord))
          (error "more than one optional argument: ~S." coord)))
  (do ((e env (cddr e))
       (n 0 (+ n 1))
       (x 0)
       (y 0))
      ((null? e)
       (cond ((= n 0) 0)
             ((eq? coord :y) (/ y n))
             ((eq? coord :x) (/ x n))
             (else (error "coord ~S not :x or :y." coord))))
    (set! x (+ x (car e)))
    (set! y (+ y (cadr e)))))

;(envelope-average '(0.0 23 20.0 73 40.0 37 60.0 8 80.0 76 100.0 36) :x)
;(envelope-average '(0.0 23 20.0 73 40.0 37 60.0 8 80.0 76 100.0 36) :y)

(define (normalize-envelope env . coord)
  (if (null? coord)
    (set! coord #t)
    (if (null? (cdr coord))
      (set! coord (car coord))
      (error "more than one optional argument: ~S." coord)))
  (let ((new (copy env))
        (x0 most-positive-fixnum)
        (x1 most-negative-fixnum)
        (y0 most-positive-fixnum)
        (y1 most-negative-fixnum))
    (do ((e env (cddr e)))
        ((null? e) #f)
      (set! x0 (min x0 (car e)))
      (set! x1 (max x1 (car e)))
      (set! y0 (min y0 (cadr e)))
      (set! y1 (max y1 (cadr e))))
    (do ((e new (cddr e)))
        ((null? e) #f)
      (if (or (eq? coord #t) (eq? coord :x))
        (set! (car e) (rescale (car e) x0 x1 0 1)))
      (if (or (eq? coord  #t) (eq? coord :y))
        (set! (car (cdr e)) (rescale (cadr e) y0 y1 0 1))))
    new))

;(normalize-envelope '(100 1 101 3 1000 20))
;(normalize-envelope '(100 1 101 3 1000 20) :y)
;(normalize-envelope '(100 1 101 3 1000 20) :x)

(define (invert-envelope env)
  (let ((y0 most-positive-fixnum)
        (y1 most-negative-fixnum)
        (cp (copy env)))
    (do ((t env (cddr t)))
        ((null? t) #f)
      (set! y0 (min y0 (cadr t)))
      (set! y1 (max y1 (cadr t))))
    (do ((t cp (cddr t)))
        ((null? t) cp)
      (set-car! (cdr t) (rescale (cadr t) y0 y1 y1 y0))
      )))

;(invert-envelope '(0 0 25 1 75 1 100 0))

(define (reverse-envelope env)
  (let ((x0 (first env))
        (x1 (envelope-max env :x))
        (cp (list)))
    (do ((t env (cddr t)))
        ((null? t) cp)
      (set! cp (cons (cadr t) cp))
      (set! cp (cons (rescale (car t) x0 x1 x1 x0) cp)))))

;(reverse-envelope '(0 0 20 .5 50 .1 90 1 100 0))

;(define (read-envelope env num)
;  (let ((x0 (first env))
;        (x1 (envelope-max env :x))
;        (cp (list #t)))
;    (do ((i 0 (+ i 1))
;         (n (- num 1))
;         (t cp)
;         (x #f))
;        ((= i num)
;         (cdr cp))
;      (set! x (rescale i 0 n x0 x1))
;      ;; do fast (destructive) appending
;      (set-cdr! t (list (interp x env )))
;      (set! t (cdr t)))
;    ))

(define (read-envelope env num . control)
  (if (null? control)
    (set! control #f)
    (if (null? (cdr control))
      (set! control (car control))
      (error "more than one optional argument: ~S." control)))
  (let ((x0 (envelope-min env :x))
        (x1 (envelope-max env :x))
        (hl (list #t))) ; head of list to collect
    (do ((i 0 (+ i 1))
         (n (- num 1))
         (t hl) ; initialize tail to head
         (x #f)
         (y #f))
        ((= i num)
         (cdr hl)) ; return collection (skipping placeholder #t)
      ;; set x to ratio between 0 and 1 inclusive
      (set! x (/ i n))  
      ;; optional lookup in user's control env (normalized)
      (if control
        (set! x (interp (/ i n) control)))
      ;; rescale x to evn's coordidates
      (set! x (rescale x 0 1 x0 x1))
      ;; collect y for x
      (set! y (interp x env ))
      ;; fast (destructive) append to tail
      (set-cdr! t (list y))
      ;; increment tail
      (set! t (cdr t)))
    ))

;(read-envelope '(0 0 1 1) 5 '(0 0 1 1))
;(read-envelope '(0 0 1 1) 5 '(0 1 1 0))
;(read-envelope '(0 0 1 1) 9 '(0 0 .25 1 .5 .33 .75 .67 1 0))

(define (interp-envelopes env0 env1 num weight)
  (let* ((h (list #t)))
    (do ((i 0 (+ i 1))
         (s (- num 1))
         (a (read-envelope env0 num) (cdr a))
         (b (read-envelope env1 num) (cdr b))
         (w weight)
         (t h))
        ((null? a) (cdr h))
      ;; if weight is an env look up current weight
      ;; weight. the env must be 0->1 on x axis!
      (if (pair? weight)
        (set! w (interp (/ i s) weight)))
      ;; weighted average of samples from envelopes
      (set! (cdr t)
            (list (+ (* (car a) (- 1 w)) (* (car b) w))))
      (set! t (cdr t)))
    ))

;(interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 1)
;(interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 0)
;(interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 .5)
;(interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 '(0 0 1 1))
;(plot-lists (list (interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 0)
;                  (interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 1)
;                  (interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 '(0 0 1 1))))
                  
;(plot-lists (list (interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 0)))
;(plot-lists (list (interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 1)))
;(plot-lists (list (interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 .5)))
;(interp-envelopes '(0 0 1 1) '(0 2 10 0) 5 .5)

